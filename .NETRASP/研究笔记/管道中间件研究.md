# 管道中间件研究

## 信息处理机制

```sequence
note left of A: 处理A请求
A->B: context
note left of B: 处理B请求
B->C: context
note left of C: 处理C请求
note left of C: 处理C回复
C->B: context
note left of B: 处理B回复
B->A: context
note left of A: 处理A回复
```

## 中间件格式

中间件的类型为`Func<RequestDelegate, RequestDelegate>`，其中`RequestDelegate`的类型为`Func<Task, HttpContext>`。为什么会采取`Func<RequestDelegate, RequestDelegate>`的格式，而不是一个`RequestDelegate`，是因为最终`Build()`将会整合为一个`RequestDelegate`，中间件的传入参数为下一个中间件，返回类型为最终整合的中间件。

## 中间件配置

可以通过继承`IMiddleware`来定义中间件:

```csharp
public interface IMiddleware
{
    Task InvokeAsync(HttpContext context, RequestDelegate next);
}
```

也可以通过定义`Lambda`表达式来配置:

```csharp
// IApplicationBuilder app;
app.Use( async (next)=>{
    return (context)=>{
        // todo: request
        await next(context);
        // todo: response
    };
};);
```
