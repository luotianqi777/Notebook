# 管道中间件研究

## 参考资料

- [App startup in ASP.NET Core](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/startup?view=aspnetcore-3.1#extend-startup-with-startup-filters)
- [How to Register Middleware in HostingStartup?](https://stackoverflow.com/questions/62990363/how-to-register-middleware-in-hostingstartup)

## 信息处理机制

```sequence
note left of A: 处理A请求
A->B: context
note left of B: 处理B请求
B->C: context
note left of C: 处理C请求
note left of C: 处理C回复
C->B: context
note left of B: 处理B回复
B->A: context
note left of A: 处理A回复
```

## 中间件格式

中间件的类型为`Func<RequestDelegate, RequestDelegate>`，其中`RequestDelegate`的类型为`Func<Task, HttpContext>`。为什么会采取`Func<RequestDelegate, RequestDelegate>`的格式，而不是一个`RequestDelegate`，是因为最终`Build()`将会整合为一个`RequestDelegate`，中间件的传入参数为下一个中间件，返回类型为最终整合的中间件。

## 中间件配置

可以通过继承`IMiddleware`来定义中间件:

```csharp
public interface IMiddleware
{
    Task InvokeAsync(HttpContext context, RequestDelegate next);
}
```

也可以通过定义`Lambda`表达式来配置:

```csharp
// IApplicationBuilder app;
app.Use( async (next)=>{
    return (context)=>{
        // todo: request
        await next(context);
        // todo: response
    };
};);
```

## 中间件构建

```csharp
public class ApplicationBuilder: IApplicationBuilder
{
    private readonly List<Func<RequestDelegate, RequestDelegate>> _middlewares = new List<Func<RequestDelegate, RequestDelegate>>();
    public RequestDelegate Build()
    {
        return httpContext =>
        {
            RequestDelegate next = _ => {
                _.Response.StatusCode = 404;
                return Task.CompletedTask;
                };
            foreach (var middleware in _middlewares.Reverse())
            {
                next = middleware(next);
            }
            return next(httpContext);
        };
    }
    public IApplicationBuilder Use(Func<RequestDelegate, RequestDelegate> middleware)
    {
        _middlewares.Add(middleware);
        return this;
    }
}
```

## 注意事项

只有在`StartUp`类`Configure`中注册的中间件可被正常调用，通过`WebHosting`直接注册的中间件会出问题。

## 结论

不可直接通过`WebHosting`来注册，可尝试通过 hook 其注册方法来注册。

## Configure 方法 hook 研究

| 命名空间                               | 类(接口)名                  | 方法名             | 备注                                           |
| -------------------------------------- | --------------------------- | ------------------ | ---------------------------------------------- |
| `Microsoft.AspNetCore.Hosting`         | `StartupBase`               | `Configure`        | 抽象方法，提供了调用`ApplicationBuilder`的接口 |
| `Microsoft.AspNetCore.Hosting`         | `WebHostBuilder`            | `Build`            | 也许会有线索                                   |
| `Microsoft.AspNetCore.Hosting`         | `WebHost`                   | `BuildApplication` | 调用了`IStartup`的`Configure`接口              |
| `Microsoft.AspNetCore.Builder`         | `ApplicationBuilder`        | `Build`            | 管道构建方式                                   |
| `Microsoft.AspNetCore.Hosting.Builder` | `ApplicationBuilderFactory` | `CreateBuilder`    | 创建`Builder`，可以尝试 hook 该方法            |

## 解决方案

- [x] **`Context`传递**
  - [x] 通过承载启动注册一个注册中间件的服务(但不确定服务的参数中能不能找到注册方法)
  - [x] 找到 asp.net 源码中底层配置中间件的方法去 hook
  - [x] 找到 http 的方法去 hook
  - [x] 找类似项目学习经验
  - [x] 注册 Http 监听服务

通过继承`IStartupFilter`可以实现通过插件配置中间件。
